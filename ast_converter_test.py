#!/usr/bin/env python3
"""
Unit tests for the `ast_converter` module.
"""
import filecmp
import os
import sys
import tempfile

import pytest

import ast_converter


def _test_stock_data_set(use_naive_to_wav: bool, use_naive_to_ast: bool):
    """
    Exercises the module by converting AST files generated by third-party tools into WAV files,
    which are then converted back to AST.
    """
    if not os.getenv('AST_TEST_DATA_SET_DIR'):
        pytest.fail('AST_TEST_DATA_SET_DIR environment variable not set. A path to a directory '
                    'containing stock AST files must be provided.')

    data_set_dir = os.environ['AST_TEST_DATA_SET_DIR']
    if not os.path.isdir(data_set_dir):
        pytest.fail(f'"{data_set_dir}" is not a valid directory.')

    filepaths = []
    visited_filenames = set()

    for dirpath, dirnames, filenames in os.walk(data_set_dir):
        dirnames.sort()
        for filename in sorted(filenames):
            if filename.endswith('.ast') and filename not in visited_filenames:
                filepath = os.path.join(dirpath, filename)
                filepaths.append(filepath)
                visited_filenames.add(filename)

    if not filepaths:
        pytest.fail(f'"{data_set_dir}" does not contain AST files.')

    for filepath in filepaths:
        with tempfile.TemporaryDirectory() as tmp_dir:
            tmp_ast_filepath = os.path.join(tmp_dir, os.path.basename(filepath))
            tmp_wav_filepath = os.path.splitext(tmp_ast_filepath)[0] + '.wav'

            ast_converter._NUMPY_AVAILABLE = use_naive_to_wav
            ast_converter.convert_to_wav(filepath, tmp_wav_filepath)

            # TODO(CA): Here we could verify whether the WAV file contains generally "not noise".
            # I've done this in the past by calculating the percentage of samples whose difference
            # with their preceding sample exceeded a predefined threshold.

            ast_info = ast_converter.get_ast_info(filepath)

            ast_converter._NUMPY_AVAILABLE = use_naive_to_ast
            ast_converter.convert_to_ast(tmp_wav_filepath,
                                         tmp_ast_filepath,
                                         looped=ast_info['looped'],
                                         sample_count=ast_info['sample_count'],
                                         loop_start=ast_info['loop_start'],
                                         loop_end=ast_info['loop_end'],
                                         volume=ast_info['volume'],
                                         last_block_size=ast_info['last_block_size'])

            assert filecmp.cmp(filepath, tmp_ast_filepath)


def test_numpy_is_available():
    assert ast_converter._NUMPY_AVAILABLE


def test_stock_data_set_naive():
    previous_value = ast_converter._NUMPY_AVAILABLE
    try:
        _test_stock_data_set(True, True)
    finally:
        ast_converter._NUMPY_AVAILABLE = previous_value


def test_stock_data_set_numpy():
    previous_value = ast_converter._NUMPY_AVAILABLE
    try:
        _test_stock_data_set(False, False)
    finally:
        ast_converter._NUMPY_AVAILABLE = previous_value


def test_stock_data_set_naive_numpy():
    previous_value = ast_converter._NUMPY_AVAILABLE
    try:
        _test_stock_data_set(True, False)
    finally:
        ast_converter._NUMPY_AVAILABLE = previous_value


def test_stock_data_set_naive_numpy():
    previous_value = ast_converter._NUMPY_AVAILABLE
    try:
        _test_stock_data_set(False, True)
    finally:
        ast_converter._NUMPY_AVAILABLE = previous_value


if __name__ == '__main__':
    sys.exit(pytest.main(sys.argv))
